/**
	SS6Player for CPP(C++/ssbp2)
	Platform: OpenGL(GLFW+GLEW)

	Copyright(C) Web Technology Corp.
	All rights reserved.
*/
/* ========================================================================== */
/* MEMO:                                                                      */
/* 各種バッファ機能群です。                                                   */
/* ※現在はGPUへの転送用バッファ関係しかないですが、後から通信転送バッファな  */
/*   ども作成される可能性があるため、Buffer名前空間にまとめるようにしました。 */
/* -------------------------------------------------------------------------- */
/* ▼GPUバッファについて                                                      */
/* GPUへのシェーダ定数（などの）転送領域管理機能です。                        */
/*                                                                            */
/* 原則的には、Memory-MappedでGPUへのデータの転送などを行うための機能になり、 */
/* SwitchやVulkan・DirectX12のいずれのプラットフォームでも同様のの機構が存在  */
/* するものの抽象化・簡便化を行っています。                                   */
/*                                                                            */
/* 基本的には、シングルバッファとマルチバッファの機能が存在しており、GPU描画  */
/* のスレッドと衝突する恐れのあるものはマルチバッファで運用する方が安全です。 */
/* ※ただし、約「スワップチェイン倍」のメモリ領域を使用します。               */
/*                                                                            */
/* ※できれば（描画時に結構回る関数なので）静的クラスにしておきたいのですが、 */
/*   レンダラでシングルバッファもマルチバッファも分け隔てなく扱わなくてはなら */
/*   ない関係から、基底継承＋仮想関数での実装になっています。                 */
/* ========================================================================== */
#pragma once

/* -------------------------------------------------------------------------- */
/*                                                 Includes / Compile-Options */
/* -------------------------------------------------------------------------- */
#include "ss6player_types.h"
#include "ss6player_renderer.h"

namespace SpriteStudio6	{
namespace Buffer	{
/* -------------------------------------------------------------------------- */
/*                                                Defines (Value-Type Macros) */
/* -------------------------------------------------------------------------- */
	/* バッファのメモリタイプ種別 */
	/* MEMO: 本来はCPU側からとGPU側からのメモリの扱われ方で分類するのが良いのですが、 */
	/*       煩雑になりがちなので、用途別で分類しておきます。                         */
	enum KindUsageBufferGPU	{
		USAGE_NONE = -1,							/* 用途なし（起動前・使用禁止） */

		USAGE_CODESHADER,							/* シェーダコード *//* ※予約（未実装） */
		USAGE_CONSTANT,								/* 定数バッファ */

		USAGE_DATAVERTEX,							/* 頂点データ */
		USAGE_DATAINDEX,							/* 頂点インデックス */

		USAGE_TEXTURE,								/* テクスチャ *//* ※予約（未実装） */

		USAGE_TERMINATOR,							/* 番兵（使用禁止） */
	};

/* -------------------------------------------------------------------------- */
/*                                            Classes / Structures / Typedefs */
/* -------------------------------------------------------------------------- */
/* GPUバッファ管理（基底） */
/* MEMO: 全てのBufferの基底クラスです。                                   */
/*       実質インタフェースクラスなので、本クラス単体で実体化できません。 */
/*       ※基本的に外部から直接使用しないでください。                     */
class GPUBase
{
	/* ----------------------------------------------- Classes, Structs,Interfaces & Typedefs */
private:
protected:
public:
	/* バッファチャンク */
	/* MEMO: 本クラスが1つの（プラットフォームに直結した）GPUバッファを管理します。   */
	/*       ※例えばGPUSingleなら内部に1つ・GPUMultiなら複数の本クラスを所有します。 */
	/* MEMO: 本クラスはGPUSingle/GPUMultiクラス以外での実体化を行わないでください。 */
	/*       ※将来でのGPUSingle/Multiオブジェクトの内部バッファ分割遅延解放などの  */
	/*         機能追加のために単独クラス化されています。                           */
	class Chunk
	{
		/* ----------------------------------------------- Classes, Structs,Interfaces & Typedefs */
	private:
	protected:
	public:

		/* ----------------------------------------------- Enums & Constants */
	private:
	protected:
	public:

		/* ----------------------------------------------- Variables */
	private:
		/* MEMO: privateについてはプラットフォーム毎で内容が変わっても問題ありません。 */
		/*       ※機種非依存部からはアクセスしません。                                */
		GLenum TypeBuffer;													/* バッファのタイプ */
		GLuint IDBuffer;													/* バッファオブジェクトID */
		size_t SizeBuffer;													/* 実際に取得されているバッファ長 */

	protected:
	public:
		/* MEMO: publicについてはプラットフォーム問わず同じである必要があります。 */

		/* ----------------------------------------------- Functions */
	private:
		/* ********************************************************* */
		//! 未使用化
		/*!
		@param	なし

		@retval	なし

		本クラスを未使用状態にします。
		*/
		void CleanUp(void);

	protected:
	public:
		/* ********************************************************* */
		//! コンストラクタ
		/*!
		@param	なし

		@retval	なし
		*/
		Chunk(void);

		/* ********************************************************* */
		//! デストラクタ
		/*!
		@param	なし

		@retval	なし
		*/
		~Chunk(void);

		/* ********************************************************* */
		//! 本クラスが有効か？
		/*!
		@param	なし

		@retval	関数値
			true == 有効
			false == 無効（値が設定されていない）

		本クラスが描画用として使用可能かを返します。
		*/
		bool IsValid(void) const;

		/* ********************************************************* */
		//! ワークエリアのヒープサイズの取得
		/*!
		@param	なし

		@retval	関数値
			ワークサイズのバイト数
			0 == ワークの必要なし

		チャンクの動作に必要なワークエリアのサイズを取得します。
		ワークの取得そのものは呼出元（本クラスの所有クラス）の役割
			になります。
		*/
		static size_t SizeGetWorkArea(void);

		/* ********************************************************* */
		//! バッファの起動
		/*!
		@param	usage
			使用目的
		@param	size
			バッファのバイトサイズ
		@param	work
			ワーク
			nullptr == ワークは自動で取得する
			省略時: nullptr

		@retval	関数値
			true == 成功
			false == 失敗

		チャンクを初期設置します。
		workに与えるメモリの実体は、必ずSizeGetWorkArea()バイト以上が
			保証されている必要があります。
		*/
		bool BootUp(KindUsageBufferGPU usage, size_t size, void* work);

		/* ********************************************************* */
		//! チャンクの終了
		/*!
		@param	なし

		@retval	なし

		チャンクを解放します。
		本関数を実行する際には、チャンクの管理しているGPUバッファが
			描画スレッドで使用されていない必要があることに注意してく
			ださい。
		※CPU処理で使用していなくても、描画側で使用している最中に
			解放すると、最悪ハングアップします。
		*/
		void ShutDown(void);

		/* ********************************************************* */
		//! チャンクが管理しているバッファを仮想メモリにマッピング
		/*!
		@param	なし

		@retval	関数値
			バッファの仮想メモリポインタ

		GPU上のバッファにアクセスするための仮想メモリポインタを取得
			します。
		CPUからバッファの内容にアクセスする際には、メモリプール上を
			直接するのではなく、必ず本関数で取得された仮想メモリポイ
			ンタを通してアクセスしてください（実アドレスはロックされ
			ている場合があります）。
		*/
		void* Map(void);

		/* ********************************************************* */
		//! チャンクが管理しているバッファを仮想メモリからアンマッピング
		/*!
		@param	なし

		@retval	なし

		GPU上のバッファにアクセスするための仮想メモリをアンマップ
			します。
		実は大半の場合、マッピングポインタは固定なので、アンマップの
			必要はないのですが……便宜上「バッファへのCPUからのアクセ
			スが終了」した段階で本関数を叩いてください。
		*/
		void Unmap(void);

		/* ********************************************************* */
		//! チャンクが管理しているバッファのGPU上アドレスを取得
		/*!
		@param	gpuAddress
			GPUアドレスの取得先

		@retval	なし
		@retval	gpuAddress
			GPUアドレス

		基本的に描画コマンドにバッファのGPUアドレスを指定する時に
			設定値の取得のために使用します（それ以外では使用しないで
			ください）。
		*/
		void AddressGetGPU(TypeAddressGPU* gpuAddress) const;

		/* ********************************************************* */
		//! バッファにデータを転送
		/*!
		@param	data
			転送するデータの戦闘
		@param	size
			転送するデータの大きさ

		@retval	関数値
			true == 成功
			false == 失敗

		バッファにデータを転送します。
		シェーダ定数構造体などの転送時の定型処理なので、マクロ機能
			関数として作成してあります。
		*/
		bool DataSet(const void* data, size_t size);

		/* ----------------------------------------------- Functions (static) */
	private:
	protected:
	public:

		/* ----------------------------------------------- Operators */

		/* ----------------------------------------------- Friends */
		friend class GPUDeleterChunk;
		friend class GPUSingle;
		friend class GPUMulti;
	};

	/* ----------------------------------------------- Enums & Constants */
private:
protected:
public:

	/* ----------------------------------------------- Variables */
private:
protected:
public:
	/* MEMO: publicについてはプラットフォーム問わず同じである必要があります。 */
	KindUsageBufferGPU Usage;						/* バッファの用途 */
	size_t Size;									/* バッファのサイズ */

	/* ----------------------------------------------- Functions */
private:
	/* MEMO: privateについてはプラットフォーム毎で内容が変わっても問題ありません。 */

protected:
	/* ********************************************************* */
	//! 未使用化
	/*!
	@param	なし

	@retval	なし

	基本的に本関数は派生側のCleanUpから呼び出してください。
	*/
	inline void CleanUp(void)
	{
		Usage = KindUsageBufferGPU::USAGE_NONE;
		Size = 0;
	}

public:
	/* ********************************************************* */
	//! コンストラクタ
	/*!
	@param	なし

	@retval	なし
	*/
	GPUBase(void)
	{
//		CleanUp();
	}

	/* ********************************************************* */
	//! デストラクタ
	/*!
	@param	なし

	@retval	なし

	継承時のために仮想デストラクタになっています。
	*/
	virtual ~GPUBase(void)
	{
//		CleanUp();
	}

	/* ********************************************************* */
	//! 本クラスが有効か？
	/*!
	@param	なし

	@retval	関数値
		true == 有効
		false == 無効（値が設定されていない）

	本クラスが描画用として使用可能かを返します。
	*/
	virtual bool IsValid(void) const = 0;

	/* ********************************************************* */
	//! バッファの起動
	/*!
	@param	usage
		使用目的
	@param	size
		バッファのバイトサイズ
	@param	work
		ワーク
		nullptr == 本関数内部でアロケートする

	@retval	関数値
		true == 成功
		false == 失敗

	バッファを初期設置します。
	workに実効メモリポインタ（!nullptr）を与える場合、workの実体
		は、かならずSizeGetWorkArea関数の値以上のバイト長である
		必要があります。
	*/
	virtual bool BootUp(KindUsageBufferGPU usage, size_t size, void* work) = 0;

	/* ********************************************************* */
	//! バッファの終了
	/*!
	@param	なし

	@retval	なし

	バッファを解放します。

	実クラス（派生クラス）側の実装によっては、本関数を実行する際
		には、バッファが描画スレッドで使用されていないことが保証
		されていなくてはならないことに注意してください。
	※CPU処理で使用していなくても、描画側で使用している最中に
		解放すると、最悪ハングアップします。
	※標準状態では、派生側で所持している内部バッファは遅延解放して
		いるので、本関数が処理されても内部バッファが即時解放されない
		実装になっています。
	*/
	virtual void ShutDown(void) = 0;

	/* ********************************************************* */
	//! バッファを仮想メモリにマッピング
	/*!
	@param	index
		アンマップするバッファの内部インデックス
		省略時: -1（現在CPU側で変更可能なインデックスを自動判定）

	@retval	関数値
		バッファの仮想メモリポインタ

	GPU上のバッファにアクセスするための仮想メモリポインタを取得
		します。
	CPUからバッファの内容にアクセスする際には、メモリプール上を
		直接するのではなく、必ず本関数で取得された仮想メモリポイ
		ンタを通してアクセスしてください（実アドレスはロックされ
		ている場合があります）。
	*/
	virtual void* Map(int index) = 0;

	/* ********************************************************* */
	//! バッファを仮想メモリからアンマッピング
	/*!
	@param	index
		アンマップするバッファの内部インデックス
		省略時: -1（現在CPU側で変更可能なインデックスを自動判定）

	@retval	なし

	GPU上のバッファにアクセスするための仮想メモリをアンマップ
		します。
	実は大半の場合、マッピングポインタは固定なので、アンマップの
		必要はないのですが……便宜上「バッファへのCPUからのアクセ
		スが終了」した段階で本関数を叩いてください。
	*/
	virtual void Unmap(int index) = 0;

	/* ********************************************************* */
	//! バッファのGPU上アドレスを取得
	/*!
	@param	gpuAddress
		GPUアドレスの取得先

	@retval	なし
	@retval	gpuAddress
		GPUアドレス

	基本的に描画コマンドにバッファのGPUアドレスを指定する時に
		設定値の取得のために使用します（それ以外では使用しないで
		ください）。
	*/
	virtual void AddressGetGPU(TypeAddressGPU* gpuAddress) const = 0;

	/* ********************************************************* */
	//! バッファにデータを転送
	/*!
	@param	data
		転送するデータの戦闘
	@param	size
		転送するデータの大きさ

	@retval	関数値
		true == 成功
		false == 失敗

	バッファにデータを転送します。
	シェーダ定数構造体などの転送時の定型処理なので、マクロ機能
		関数として作成してあります。
	*/
	virtual bool DataSet(const void* data, size_t size) = 0;

	/* ********************************************************* */
	//! 初期データをバッファにデータを転送
	/*!
	@param	data
		転送するデータの戦闘
	@param	size
		転送するデータの大きさ

	@retval	関数値
		true == 成功
		false == 失敗

	バッファに初期データを設定します。
	基本的にDataSetで代用することは可能なのですが、本関数はユー
		ティリティ機能として初期値を設定することに特化した実装を
		することを推奨します。
	※例えばマルチバッファの場合、全内部バッファに指定値を設定す
		る……など。
	*/
	virtual void DataSetInitial(const void* data, size_t size) = 0;

	/* ----------------------------------------------- Functions (static) */
private:
protected:
public:

	/* ----------------------------------------------- Operators */

	/* ----------------------------------------------- Friends */
};

/* GPUバッファ遅延解放処理 */
/* MEMO: GPUバッファの内、GPU使用中のバッファを削除したりしないように、遅延 */
/*       解放処理などを行うための機能です。                                 */
/*       システム中枢機能ですので、原則外部から呼び出さないでください。     */
/*       ※本クラスは静的クラスですので、実体を作成しないでください。       */
/*                                                                          */
/*       GPUバッファ自体は即時解放が可能なように、GPUバッファ内のChunk毎に  */
/*       分解して管理されます（正確にはChunkが持つ内部バッファのみを管理し  */
/*       ますのでChunkクラスの実体自体は即時解放が可能です）。              */
class GPUDeleterChunk
{
	/* ----------------------------------------------- Classes, Structs,Interfaces & Typedefs */
private:
protected:
public:

	/* ----------------------------------------------- Enums & Constants */
private:
protected:
public:

	/* ----------------------------------------------- Variables */
private:
protected:
public:

	/* ----------------------------------------------- Functions */
private:
protected:
public:

	/* ----------------------------------------------- Functions (static) */
private:
protected:
public:
	/* ********************************************************* */
	//! 起動
	/*!
	@param	countChunkMax
		1フレームで処理可能な最大チャンク数

	@retval	関数値
		true == 成功
		false == 失敗

	GPUバッファ遅延解放処理を起動します。

	※内部でMemory::Allocateを使用しています。
	*/
	static bool BootUp(int countChunkMax);

	/* ********************************************************* */
	//! 終了
	/*!
	@param	なし

	@retval	なし

	GPUバッファ遅延解放処理を終了します。
	本関数実行後はExecuteを実行しても削除処理が行われませんので、
		必ずIsBufferedがfalseであることを確認してから本関数を実行
		してください。

	※内部でMemory::Freeを使用しています。
	*/
	static void ShutDown(void);

	/* ********************************************************* */
	//! 解放チャンクがバッファリングされているかを取得
	/*!
	@param	なし

	@retval	関数値
		true == 残っている
		false == 空（残っていない）

	現在解放するべきオブジェクトが残っているかどうかを取得します。
	*/
	static bool IsBuffered(void);

	/* ********************************************************* */
	//! 解放処理実行
	/*!
	@param	なし

	@retval	関数値
		true == 成功
		false == 失敗

	バッファリングされているオブジェクトの内、当該タイミングで解放
		可能なものを実際に解放します。
	本関数は、SpriteStudio6::SystemProcessMainPre関数内から呼ばれ
		ますので、外部から独自に呼び出さないでください。
	*/
	static bool Execute(void);

	/* ********************************************************* */
	//! 解放処理実行要求
	/*!
	@param	なし

	@retval	なし

	次のExecuteで遅延処理を実行することを要求します。
	本関数は、SpriteStudio6::SystemProcessRenderPost関数内から
		呼ばれますので、外部から独自に呼び出さないでください。
	*/
	static void ExecuteRequest(void);

	/* ********************************************************* */
	//! チャンクを削除定義
	/*!
	@param	chunk
		削除対象のチャンク
	@param	flagSideUpdate
		true == 今回処理ループで更新している（次の描画で使用する）
		false == 今回は使用していない（裏で描画で使用している）

	@retval	関数値
		true == 成功
		false == 失敗

	指定したチャンクの持っているオブジェクト群を削除定義します。
	本関数終了後、chunk自体はディスポーズしてしまって構いません。
	本関数は、各Buffer::GPU～クラスのShutDownの中から呼ばれますの
		で、外部から明示的に呼び出さないでください。
	*/
	static bool ChunkSet(GPUBase::Chunk& chunk, bool flagSideUpdate);

	/* ----------------------------------------------- Operators */

	/* ----------------------------------------------- Friends */
};

/* GPUバッファ管理（シングル） */
/* MEMO: 描画中にCPUから値を変更しない（描画スレッドと通常処理スレッドが並列競合しない） */
/*       ようなバッファについては、本クラスを用いる方が効率的です。                      */
/* MEMO: 原則本クラスはnewせずに領域をmallocした場合は、必ず明示的にコンストラクタを */
/*       走らせてください（配置newしてください）。                                   */
/*       理由としては、nn::gfx::Bufferがコンストラクタが実行されていない場合にハング */
/*       アップしてしまうためです。                                                  */
class GPUSingle :
	public GPUBase
{
	/* ----------------------------------------------- Classes, Structs,Interfaces & Typedefs */
private:
protected:
public:

	/* ----------------------------------------------- Enums & Constants */
private:
protected:
public:

	/* ----------------------------------------------- Variables */
private:
	/* MEMO: privateについてはプラットフォーム毎で内容が変わっても問題ありません。 */
	/*       ※機種非依存部からはアクセスしません。                                */
	void* Work;
	Chunk Chunk;

protected:
public:
	/* MEMO: publicについてはプラットフォーム問わず同じである必要があります。 */
	/* MEMO: 基底（GPUBase）で定義されているものがあるので注意してください。 */

	/* ----------------------------------------------- Functions */
private:
	/* MEMO: privateについてはプラットフォーム毎で内容が変わっても問題ありません。 */
	/* ********************************************************* */
	//! 未使用化
	/*!
	@param	なし

	@retval	なし
	*/
	inline void CleanUp(void)
	{
		GPUBase::CleanUp();

		Work = nullptr;
		Chunk.CleanUp();
	}

protected:
public:
	/* ********************************************************* */
	//! コンストラクタ
	/*!
	@param	なし

	@retval	なし
	*/
	GPUSingle(void);

	/* ********************************************************* */
	//! デストラクタ
	/*!
	@param	なし

	@retval	なし
	*/
	~GPUSingle(void);

	/* ********************************************************* */
	//! 本クラスが有効か？
	/*!
	※基底の純粋仮想関数（インタフェース）の実装です。
	*/
	virtual bool IsValid(void) const;

	/* ********************************************************* */
	//! ワークエリアのヒープサイズの取得
	/*!
	@param	size
		確保したいGPUのバッファ長

	@retval	関数値
		ワークサイズのバイト数
		0 == ワークの必要なし
	*/
	static size_t SizeGetWorkArea(size_t size);

	/* ********************************************************* */
	//! バッファの起動
	/*!
	※基底の純粋仮想関数（インタフェース）の実装です。
	*/
	virtual bool BootUp(KindUsageBufferGPU usage, size_t size, void* work=nullptr);

	/* ********************************************************* */
	//! バッファの終了
	/*!
	※基底の純粋仮想関数（インタフェース）の実装です。
	*/
	virtual void ShutDown(void);

	/* ********************************************************* */
	//! バッファを仮想メモリにマッピング
	/*!
	※基底の純粋仮想関数（インタフェース）の実装です。

	indexはインタフェースとして共通でついているだけなので、本クラ
		スに限っては無視されます。
	*/
	virtual void* Map(int index=-1);

	/* ********************************************************* */
	//! バッファを仮想メモリからアンマッピング
	/*!
	※基底の純粋仮想関数（インタフェース）の実装です。

	indexはインタフェースとして共通でついているだけなので、本クラ
		スに限っては無視されます。
	*/
	virtual void Unmap(int index=-1);

	/* ********************************************************* */
	//! バッファのGPU上アドレスを取得
	/*!
	※基底の純粋仮想関数（インタフェース）の実装です。
	*/
	virtual void AddressGetGPU(TypeAddressGPU* gpuAddress) const;

	/* ********************************************************* */
	//! バッファにデータを転送
	/*!
	※基底の純粋仮想関数（インタフェース）の実装です。
	*/
	virtual bool DataSet(const void* data, size_t size);

	/* ********************************************************* */
	//! 初期データをバッファにデータを転送
	/*!
	※基底の純粋仮想関数（インタフェース）の実装です。
	*/
	virtual void DataSetInitial(const void* data, size_t size);

	/* ----------------------------------------------- Functions (static) */
private:
protected:
public:

	/* ----------------------------------------------- Operators */

	/* ----------------------------------------------- Friends */
};

/* バッファ管理（マルチ） */
/* MEMO: 描画中にCPUから値を変更するようなバッファについては、本クラスを用いる方が安全です。 */
/*       ※内部にスワップチェイン分のバッファを持っています。                                */
/* MEMO: 原則本クラスはnewせずに領域をmallocした場合は、必ず明示的にコンストラクタを */
/*       走らせてください（配置newしてください）。                                   */
/*       理由としては、nn::gfx::Bufferがコンストラクタが実行されていない場合にハング */
/*       アップしてしまうためです。                                                  */
class GPUMulti :
	public GPUBase
{
	/* ----------------------------------------------- Classes, Structs,Interfaces & Typedefs */
private:
protected:
public:

	/* ----------------------------------------------- Enums & Constants */
private:
protected:
public:

	/* ----------------------------------------------- Variables */
private:
	/* MEMO: privateについてはプラットフォーム毎で内容が変わっても問題ありません。 */
	/*       ※機種非依存部からはアクセスしません。                                */
#if 0	/* MEMO: 現在SpriteStudio6::CountSwapChainと同じなので、キャッシュしていません。 */
	int Count;										/* バッファの数 */
#endif
	void* Work;
	Chunk* Chunk;									/* チャンク配列の先頭 */

protected:
public:
	/* MEMO: publicについてはプラットフォーム問わず同じである必要があります。 */
	/* MEMO: 基底（GPUBase）で定義されているものがあるので注意してください。 */

	/* ----------------------------------------------- Functions */
private:
	/* MEMO: privateについてはプラットフォーム毎で内容が変わっても問題ありません。 */
	/* ********************************************************* */
	//! 未使用化
	/*!
	@param	なし

	@retval	なし
	*/
	void CleanUp(void)
	{
		GPUBase::CleanUp();

		Work = nullptr;
		Chunk = nullptr;
	}

	/* ********************************************************* */
	//! ワークエリアのヒープサイズの取得（内部処理用）
	/*!
	@param	sizeInstanceChunk
		チャンク管理クラスの実体部のバイト長の格納先（合計）
	@param	sizeWorkChunk
		チャンク管理クラスのワークのバイト長の格納先（合計）
	@param	sizeWorkChunkUnit
		チャンク管理クラスのワークのバイト長の格納先（単体）
	@param	sizeBuffer
		必要とする転送用バッファのサイズ（単体）

	@retval	関数値
		ワークサイズのバイト数
		0 == ワークの必要なし
	@retval	sizeInstanceChunk
		チャンク管理クラスの実体部のバイト長
	@retval	sizeWorkChunk
		チャンク管理クラスのワークのバイト長
	@retval	sizeWorkChunkUnit
		チャンク管理クラスのワークのバイト長
	*/
	static size_t SizeGetWorkArea(size_t* sizeInstanceChunk, size_t* sizeWorkChunk, size_t* sizeWorkChunkUnit, size_t sizeBuffer);

protected:
public:
	/* ********************************************************* */
	//! コンストラクタ
	/*!
	@param	なし

	@retval	なし
	*/
	GPUMulti(void);

	/* ********************************************************* */
	//! デストラクタ
	/*!
	@param	なし

	@retval	なし
	*/
	~GPUMulti(void);

	/* ********************************************************* */
	//! 本クラスが有効か？
	/*!
	※基底の純粋仮想関数（インタフェース）の実装です。
	*/
	virtual bool IsValid(void) const;

	/* ********************************************************* */
	//! ワークエリアのヒープサイズの取得
	/*!
	※引数の内容は基底の同名関数（の注釈化）の注釈に記載してあります。
	*/
	static size_t SizeGetWorkArea(size_t size);

	/* ********************************************************* */
	//! バッファの起動
	/*!
	※基底の純粋仮想関数（インタフェース）の実装です。
	*/
	virtual bool BootUp(KindUsageBufferGPU usage, size_t size, void* work=nullptr);

	/* ********************************************************* */
	//! バッファの終了
	/*!
	※基底の純粋仮想関数（インタフェース）の実装です。
	*/
	virtual void ShutDown(void);

	/* ********************************************************* */
	//! バッファを仮想メモリにマッピング
	/*!
	※基底の純粋仮想関数（インタフェース）の実装です。
	*/
	virtual void* Map(int index=-1);

	/* ********************************************************* */
	//! バッファを仮想メモリからアンマッピング
	/*!
	※基底の純粋仮想関数（インタフェース）の実装です。
	*/
	virtual void Unmap(int index=-1);

	/* ********************************************************* */
	//! バッファのGPU上アドレスを取得
	/*!
	※基底の純粋仮想関数（インタフェース）の実装です。
	*/
	virtual void AddressGetGPU(TypeAddressGPU* gpuAddress) const;

	/* ********************************************************* */
	//! バッファにデータを転送
	/*!
	※基底の純粋仮想関数（インタフェース）の実装です。
	*/
	virtual bool DataSet(const void* data, size_t size);

	/* ********************************************************* */
	//! 初期データをバッファにデータを転送
	/*!
	※基底の純粋仮想関数（インタフェース）の実装です。
	*/
	virtual void DataSetInitial(const void* data, size_t size);

	/* ----------------------------------------------- Functions (static) */
private:
protected:
public:

	/* ----------------------------------------------- Operators */

	/* ----------------------------------------------- Friends */
};

/* -------------------------------------------------------------------------- */
/*                                                                  Variables */
/* -------------------------------------------------------------------------- */

/* -------------------------------------------------------------------------- */
/*                                    Inline-Functions / Function-Type Macros */
/* -------------------------------------------------------------------------- */

/* -------------------------------------------------------------------------- */
/*                                                        Function Prototypes */
/* -------------------------------------------------------------------------- */

}	/* Buffer */
}	/* SpriteStudio6 */
